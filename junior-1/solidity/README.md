# Вопросы по Solidity

## Язык Solidity

1. Что можешь рассказать про язык Solidity?
    - Solidity - это интерпретируемый язык?
    - Есть ли типизация в Solidity? Если есть, то какая? Если нету, то почему?
    - Для чего был разработан этот язык?
2. Что такое EVM?
3. Понимает ли EVM язык Solidity?
4. Как дебажить написанный код? Есть ли в языке `console.log`?

## Введение в смарт контракты

1. Что такое смарт-контракт?
2. Какие особенности есть у смарт-контрактов?
    - Можно ли модифицировать смарт-контракт после деплоя?
    - Где можно посмотреть код задеплоенного смарт-контракта?
3. Могут ли контракты взаимодействовать друг с другом?
4. Может ли контракт обращаться к API сторонних сервисов.
5. На каких языках пишутся смарт-контракты?
6. Что такое gas?
    - Кто и как платит газ?
    - Что будет если газ закончится в рамках транзакции?
7. В какие сети можно разворачивать смарт-контракты?
8. Что такое ABI?
    - Какие функции не попадут в ABI?
9. Что такое bytecode?
    - Как bytecode связан с ABI?

## Структура контракта Solidity

1. Что содержит в себе смарт-контракт? Какая структура смарт-контракта?
    - Что такое pragma?
    - Какие виды лицензий бывают?
2. Что такое `constructor()`? Является ли его объявление обязательным? Когда выполняется код внутри конструктора?
3. Что такое переменные состояния(state variables)? Что такое локальные переменные? В чем отличие?
    - Что такое constant и immutable? В чем разница? Для каких типов переменных применимы constant и immutable?
4. Что такое variable shadowing?
5. Для чего нужны события?
    - Может ли контракт читать события?
    - Может ли смарт-контракт удалять события?
6. Для чего нужны модификаторы?
7. Можно ли в одном файле создавать множество смарт-контрактов?
8. Что такое selfdestruct и как работает?

## Типы. Value types

1. Что можешь рассказать про value types?
    - Booleans
    - Integers. Int. Uint.
    - Address
    - Массивы байтов с фиксированным размером(bytes1, …, bytesN).
    - Массив байт c динамическим размером(bytes).
    - Адресные литералы
    - Дробные и целочисленные литералы
    - Строковые литералы
    - Литералы Юникод
    - Шестнадцатеричные литералы
    - Типы функций
2. Что такое `uint` и чем он отличается от `uint8`, `uint256`?
3. Чем отличаются `uint` и `int`?
4. Какие есть особенности у типа address?
5. Чем отличаются динамический массив и массив с фиксированной длиной?
6. Что такое Enum?
    - Как получить наименьшее и наибольшее значение из Enum?
    - Можно ли объявлять Enum за пределами контракта?

## Типы. Reference types

1. Что можешь рассказать про reference types?
    - Data location (storage, memory, calldata)
    - Массивы (динамические и с фиксированной длиной)
    - Структуры
2. Как получить длину массива?
3. Как добавлять данные в массив?
4. Как обойти массив?
5. Как удалить произвольный элемент из массива?

## Типы. Mapping types

1. Что можешь рассказать про mapping types?
2. Могут ли mapping вкладываться друг в друга?
3. Как обойти mapping?

## Типы. Общие вопросы.

1. Что такое значение по умолчанию? Чему будут равны по умолчанию различные виды переменных?
2. Тернарный оператор. Составные операторы. Delete оператор.
3. Неявные и явные преобразования типов. В чем разница?
4. Можно ли объявить тип для undefined или null?

## Units and global variables

1. Как использовать Ether units и Time units?
2. Что такое глобальная переменная block?
3. Что такое глобальная переменная msg?
    - Чем отличается tx.origin и msg.sender?
4. Для чего используется abi.encode и abi.decode?
5. В чем разница между abi.encode и abi.encodePacked? Есть ли какие-нибудь нюансы в выборе, что использовать?
6. В чем разница между encodeWithSignature и encodeWithSelector?
7. Как работает конкатенация строк и байтов?
8. Что ты знаешь про Error Handling(assert, require, revert)?
    - В чем разница между assert и revert?
    - Какие есть перегрузки для require и revert?
9. Как работает selfdestruct?

## Выражения и структуры управления

1. Какие есть циклы в Solidity? Можно ли использовать ключевые слова break, continue, return?
2. Будет ли валиден следующий код для conditional statements выражения?
```js
  if (1) { ... }
```
3. Зачем делать пропуск именования в определение аргументов функции?

``` solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.4.22 <0.9.0;

contract C {
    // omitted name for parameter
    function func(uint k, uint) public pure returns(uint) {
        return k;
    }
}
```

4. Как создать новый контракт через new?
5. Как создать контракт через create2?
6. Как работает деструктуризация присвоений и возврат нескольких значений?
7. Что такое checked/unchecked?
8. Как работать с try/catch?

## Видимость и геттеры в контракте

1. Какие области видимости существуют у переменных состояния?
    - Какая область видимости у переменных состояния по умолчанию?
    - Какая область видимости не может быть назначена переменной состояния?
    - Можно ли считать переменную `private` извне?
2. Какие области видимости существуют у функций контракта?
    - В чем разница между external и public?
    - В чем разница между internal и private?
3. Что такое геттер функции?

## Функции контракта

1. Как вернуть несколько значений из функции?
2. Что означают модификаторы view, pure, payable?
3. Зачем нужны специальные функции fallback и receive?
    - Что будет если отправить в контракт эфир где нет fallback/receive?
4. Как работает перегрузка функций?

## Наследование

1. Как реализовать наследование?
    - Что такое ключевые слова virtual и override?
    - Можно ли наследоваться от нескольких контрактов?
2. Как вызвать функцию родителя?
3. Как переопределить функцию в дочернем контракте?
    - Можно ли изменить видимость функции? Например с external на public?
    - Можно ли изменить с view на pure?
4. Что такое абстрактные контракты?

## Интерфейсы

1. Что такое интерфейсы?
2. Для чего нужны интерфейсы в solidity?
3. В чем отличие интерфейсов от абстрактных контрактов?

## Библиотека

1. Что такое библиотека?
2. Как подключить библиотеку?
    - Что такое using for?


## Интересные вопросы

1. Округление при делении.
    - Какой ожидается результат вызова функции `roundingDivision()`? В чем заключается проблема? Как это можно обойти?
        ```solidity
        function roundingDivision() external pure returns (uint256) {
            return uint256(7) / uint256(5);
        }
        ```
    - Какой ожидается результат вызова функции `divisionByZero()`?
        ```solidity
        function divisionByZero() external pure returns (uint256) {
            return uint256(7) / 0;
        }
        ```
2. Что произойдет при вызове функции `setOwner(addressB, anyAccount)` на контракте A? Чему будет равен вызов функций `manager()` и `owner()`? Почему важен порядок переменных в этих двух контрактах?
    ```solidity
    contract A {
        address public manager;
        address public owner;

        function setOwner(address target, address account) external {
            (bool success,) = target.delegatecall(
                abi.encodeWithSignature("setOwner(address)", account)
            );

            if (!success) {
                revert();
            }
        }
    }

    contract B {
        address public owner;
        address public manager;

        function setOwner(address account) external {
            owner = account;
        }
    }
    ```
3. Работа модификаторов. Что вернут переменные `stateA`, `stateB`, `stateC` после вызова функции changeStates()?
    ```solidity
    contract Modifier {
        uint256 public stateA;
        uint256 public stateB;
        uint256 public stateC;

        modifier changeStateA() {
            stateA++;
            _;
        }

        modifier changeStateB() {
            _;
            stateB++;
            _;
        }

        function changeStates() external changeStateA changeStateB {
            stateC++;
        }
    }
    ```